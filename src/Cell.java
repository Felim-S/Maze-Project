import java.awt.*;
import java.util.ArrayList;
import java.util.Random;

public class Cell {
    public static final Random rand = new Random();

    private int x;
    private int y;
    private boolean[] walls;
    private boolean visited;

    Cell(int i, int j) {
        // Converting (smaller) integers i,j to x,y values based on grid
        this.x = i * Panel.GRID_SIZE;
        this.y = j * Panel.GRID_SIZE;
        // Walls = {Top, Right, Bottom, Left}
        this.walls = new boolean[]{true, true, true, true};
        this.visited = false;
    }

    public boolean[] getWalls() {
        return walls;
    }

    public int getY() {
        return y;
    }

    public int getX() {
        return x;
    }

    public void setWalls(boolean bool, int index) {
        this.walls[index] = bool;
    }

    public void setVisited(boolean visited) {
        this.visited = visited;
    }

    public void show(Graphics g, Cell[][] grid) {
        x = this.getX();
        y = this.getY();
        int w = Panel.GRID_SIZE;

        // Draw lines corresponding to Cell walls
        g.setColor(Color.black);
        // Top
        if(this.getWalls()[0]){
            g.drawLine(x,y,x+w,y);
        }
        // Right
        if(this.getWalls()[1]){
            g.drawLine(x+w,y,x+w,y+w);
        }
        // Bottom
        if(this.getWalls()[2]){
            g.drawLine(x+w,y+w,x,y+w);
        }
        // Left
        if(this.getWalls()[3]){
            g.drawLine(x,y+w,x,y);
        }

        if(this.visited){
            // To visualise visited squares, mark them with any arbitrary colour
            // (*Note: this colour's alpha should be < 255 to see grid lines)
            g.setColor(new Color(0, 51, 255, 184));
            g.fillRect(x,y,Panel.GRID_SIZE,Panel.GRID_SIZE);
        }
    }

    public void highlight(Graphics g) {
        int x = this.getX();
        int y = this.getY();
        g.setColor(new Color(0, 0, 0));
        g.fillRect(x,y,Panel.GRID_SIZE,Panel.GRID_SIZE);
    }

    public Cell getNeighbour(Cell[][] grid) {
        // neighbours will serve as an array of options for the next cell
        ArrayList<Cell> neighbours = new ArrayList<Cell>();
        // Converting x, y back to integers corresponding to i,j
        int x = this.getX() / Panel.GRID_SIZE;
        int y = this.getY() / Panel.GRID_SIZE;

        // Check each neighbour only if within bounds of grid
        // (*Portion dealing with edge cases generated by ChatGPT*)
        Cell top = (y - 1 >= 0) ? grid[x][y - 1] : null;
        Cell right = (x + 1 < Panel.ROWS) ? grid[x + 1][y] : null;
        Cell bottom = (y + 1 < Panel.COLS) ? grid[x][y + 1] : null;
        Cell left = (x - 1 >= 0) ? grid[x - 1][y] : null;

        // If the neighbour is not visited, add it to our array
        if (top != null && !top.visited) {
            neighbours.add(top);
        }
        if (right != null && !right.visited) {
            neighbours.add(right);
        }
        if (bottom != null && !bottom.visited) {
            neighbours.add(bottom);
        }
        if (left != null && !left.visited) {
            neighbours.add(left);
        }
        // If there are more than one neighbours, pick a random one to return
        if(!neighbours.isEmpty()){
            return neighbours.get(rand.nextInt(0, neighbours.size()));
        } else{
            // If there are no neighbours, return null
            return null;
        }
    }

    public static void removeWalls(Cell a, Cell b) {
        int distanceX = a.getX()/Panel.GRID_SIZE - b.getX()/Panel.GRID_SIZE;
        int distanceY = a.getY()/Panel.GRID_SIZE - b.getY()/Panel.GRID_SIZE;

        // a is to the right of b
        if(distanceX == 1){
            a.setWalls(false,3);
            b.setWalls(false,1);
        }
        // a is to the left of b
        if(distanceX == -1){
            a.setWalls(false,1);
            b.setWalls(false,3);
        }
        // a is below b
        if(distanceY == 1){
            a.setWalls(false,0);
            b.setWalls(false,2);
        }
        // a is above b
        if(distanceY == -1){
            a.setWalls(false,2);
            b.setWalls(false,0);
        }
    }
}
